## 复杂度
### 复杂度的概念
复杂度 (Complexity) 分为时间复杂度和空间复杂度，并称时空复杂度，是以问题规模 $n$ 为自变量的函数

时间复杂度描述的是执行一个算法需要消耗的时间的量级，时间复杂度越低则表示算法越优秀，并不是描述一个算法在某台计算机上执行消耗的具体时间，在不同的计算机上执行相同的程序很可能会消耗不同的时间，这不影响一个算法的时间复杂度。

空间复杂度描述的是执行一个算法需要消耗的存储空间的量级，空间复杂度越低则算法越优秀，对于一个算法来说，其时空复杂度往往是相互影响的，在追求较低的时间复杂度时可能会使空间复杂度变差，反之亦然

通常我们更关注算法在最坏情况下的时空复杂度，并以此评估程序能否在指定时间、指定空间下解决问题
### 渐进符号
如果 $f(n) = O(g(n))$，表示 $f(n)$ 的增长速度至多和 $g(n)$ 一样快，这种记号称为 $O$ 表示法 (大 $O$ 表示法)

如果 $f(n) = \Omega(g(n))$，表示 $f(n)$ 的增长速度至少和 $g(n)$ 一样快，这种记号称为 $\Omega$ 表示法 (大 $\Omega$ 表示法)

如果 $f(n) = \Theta(g(n))$，表示 $f(n)$ 的增长速度和 $g(n)$ 一样快，这种记号称为 $\Theta$ 表示法 (大 $\Theta$ 表示法)

在描述一个算法的时空复杂度时， $\Theta$ 表示法最精确，实际应用中会更多地使用 $O$ 表示法粗略描述一个算法的复杂度
### 复杂度的比较
当问题的规模 $n\to+\infin$ 时，$n$ 对 $f(n)$ 增长速度的影响远大于常数项，并且此时高阶项的增长速度远大于低阶项，因此对于复杂度来说只需要关注最高阶的一项，通过比较最高阶的增长速度来评价复杂度的优劣

常见的复杂度优劣的比较：
$O(1)<O(logn)<O(\sqrt{n})<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$

其中对数阶的底数通常不写，默认是 $2$ ，其他底数的对数可以通过换底公式转换为以 $2$ 为底的对数，原来的底数就是 $logn$ 前面的常数，例如：$log_3n=\frac{log_2n}{log_23}=\frac{1}{log_23}logn$，因此即使底数不同也属于同阶
### 普通递归算法的时间复杂度
以汉诺塔问题的递归解法为例

有 $n$ 个盘片要移动到 $C$ 柱，根据规则，要先将上面 $n-1$ 个盘片移动到 $B$ 柱，再移动最下面 $1$ 个盘片到 $C$ 柱，然后把剩下的 $n-1$ 个盘片移动到 $C$ 柱，这样就完成了，对于那 $n-1$ 个盘片，可以采取相同的策略，把上面 $n-2$ 个盘片先移动到 $A$ 柱，此时 $B$ 柱上是编号为 $n-1$ 的第 $2$ 大的盘片，将它移动到 $C$ 柱即可，依此类推，可以递推到只有 $2$ 个盘片的情况，而当只有 $1$ 个盘片时，只需要将盘片从 $A$ 柱移动到 $C$ 柱就完成了，这就是一个递归算法的过程

函数参数中的 $A$ 代表起始位置，$B$ 代表中间的过渡位置，$C$ 代表目标位置，并非指实际的 $A, B, C$ 柱
```cpp
void hanoi(int n, char A = 'A', char B = 'B', char C = 'C') {
    if (n == 1) {
        std::cout << "盘片" << n << ": " << A << "->" << C << "\n";
        return;
    }
    hanoi(n - 1, A, C, B);
    std::cout << "盘片" << n << ": " << A << "->" << C << "\n";
    hanoi(n - 1, B, A, C);
}
```
该算法的时间复杂度为
$$
\large
T(n) = 
\left\{
    \begin{array}{lr}
    O(1), \quad n = 1  \\\\
    2T(n-1)+1, \quad n > 1
    \end{array}
\right.
$$
当 $n>1$ 时，变形该递推式
$$
\large
\begin{align*}
T(n)
&= 2T(n-1)+1\\ 
&= 2[2T(n-2)+1]+1\\
&= 2^2T(n-2)+2+1\\
&= 2^2[2T(n-3)+1]+2+1\\
&= 2^3T(n-3)+2^2+2+1\\
&=\dots\\
&=2^{n-1}T(1)+2^{n-2}+\dots+2+1\\
&=2^{n-1}+2^{n-2}+\dots+2+1\\
&=2^n-1\\
\end{align*}
$$
当 $n=1$ 时，$T(1)=1$ 也满足此式，最后可以得到汉诺塔递归算法的时间复杂度 $T(n) = O(2^n)$
### 尾递归
## 分治算法
### 分治算法的时间复杂度
### 主定理 ( Master Theorem )
设时间复杂度为 $T(n)$，则 
$$\large T(n) = aT(\frac{n}{b}) + f(n)$$
其中，$n$ 为问题的规模，$a$ 为子问题的个数，$\frac{n}{b}$ 为每个子问题的大小，假设每个子问题的大小相同，$f(n)$ 为将原问题分解为子问题和将子问题合并为原问题的总时间复杂度

$$
\Large
T(n)=
\left\{
    \begin{array}{lr}
    O(n^{log_ba}),\quad n^{log_ba} > f(n) \\\\
    O(f(n)),\quad n^{log_ba} < f(n) \\\\
    O(n^{log_ba}logn),\quad n^{log_ba} = f(n)
    \end{array}
\right.
$$