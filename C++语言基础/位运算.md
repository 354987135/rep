&
a & 1 = a
a & 0 = 0

|
a | 0 = a

^
a ^ a = 0
~
取反是以补码形式取反，因此负数取反会变成正数，正数取反会变成负数
例如

>>
对于有符号数，右移正数高位补0，负数高位补1

<<
注意C++20之前负数左移是未定义行为
# 位运算
```cpp
void Swap(int& a, int& b)
{
    //如果a和b指向同一块内存则结果为0
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}
```
取出一个整数n末尾的1，即保留n的补码最右侧的一位1，其他位为0：
$$
    \Large
    n\,\&\,(\sim n + 1) 
$$
例1：n为负数
$$
\Large
\begin{align*}
    n &= 11110101 \quad \text{$-11$ 的补码}\\
    \sim n &= 00001010 \quad \text{各位全部取反}\\
    \sim n + 1 &= 00001011 \quad \text{取反后$+1$}\\
    n\,\&\,(\sim n + 1) &= 00000001 \quad \text{取出末位 $1$}
\end{align*}
$$
例2：n为正数
$$
\Large
\begin{align*}
    n &= 01011000 \quad \text{$88$ 的补码}\\
    \sim n &= 10100111 \quad \text{各位全部取反}\\
    \sim n + 1 &= 10101000 \quad \text{取反后$+1$}\\
    n\,\&\,(\sim n + 1) &= 00001000 \quad \text{取出末位 $1$}
\end{align*}
$$
```cpp
#include <iostream>
#include <cstdint>
#include <bitset>
int main() {
    std::int8_t n1 = -11, n2 = 88;
    std::bitset<8> bs1 = n1 & (~n1 + 1);
    std::bitset<8> bs2 = n2 & (~n2 + 1);
    std::cout << bs1 << ' ' << bs2;
    //输出: 00000001 00001000
}
```
