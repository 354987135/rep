//2x + 3y = 18
//已
#include <iostream>
using namespace std;
int main() {
//	1 2 3 4 5 6 7 8 9 10
//	把这一列数看成一个整体
//	它就是一维数组
//	
//	int a[10]; // 数组声明
//	上面的语句声明了一个变量名为a的数组
//	这个数组保存的数据元素是int类型，简称int数组 
//	这个数组能够保存的元素的最大个数是10个
//	
//	[] 内指定的叫做数组长度，表示能够存储数据的最大数量
//	实际使用的时候可以不存那么多
//	
//	int b[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
//	上面的语句声明了一个变量名为b的int数组
//	并且将他的第1~第10个元素分别初始化为 1 ~ 10
//	int c[10] = {1, 2, 3};
//	上面的语句把1 2 3分别存储为数组c的第1~第3个元素
//	剩下的第4~第10个元素会被自动赋值为 0
//	
//	根据上面这个特性，
//	我们可以得到将整个数组初始化为0的方法：
//	int d[10] = {0}; 
//	上面的语句就把数组d的每一个元素都初始化成了0 
//	
//	实际上如果我们在声明数组的时候就给它赋值
//	那么我们可以在声明语句中省略数组长度
//	这样编译器会根据后面赋值的元素个数，
//	自动推断出数组的长度
//	int e[] = {1, 2, 3};
//	上面的语句就创建了一个含有3个元素的int数组e
//	1 2 3分别是数组e的第1~第3个元素
//	
//	我们可以只声明数组长度，但不初始化
//	int f[3]; <--- 正确 
//	也可以直接初始化，不写长度
//	int f[] = {4, 5, 6}; <--- 正确 
//	但是不能两个都不写
//	int f[]; <--- 错误的写法
//	
//	其实在初始化的时候，= 可以省略
//	
//	int g[3] {2, 2, 3};  <--- 等同于 int g[3] = {2, 2, 3}; 
//	int g[] {5, 4, 3};  <--- 等同于 int g[] = {5, 4, 3};
//	
//	特别地，对于int g[3] = {0};
//	我们可以直接写 int g[3] {}; 
//	= 和大括号中的0都可以省略 
//	
//	另外一个注意点：
//	当指定数组长度的时候
//	这个长度数字必须是常量表达式，而且必须是正整数 
//	什么是常量表达式？
//	常量表达式就是可以在编译期就得到结果的表达式
//	并且这个数字在程序运行过程中不能改变 
//	例如这一个语句: int a = 3 + 4 + 5;
//	其中 3 + 4 + 5 就是一个常量表达式
//	在编译的时候，编译器会直接计算出它的结果：12
//	然后上面的语句实际上就变成了 int a = 12;
//	显然，12这个数字在程序运行过程中是不会改变的
//	
//	
//	int n;    
//	cin >> n; 
//	int a[n]; <--- 这样的写法是错误的
//	因为n不是一个常量表达式
//	n的值需要等到程序运行时才能确定
//	 
//	但是如果你真的这么写，你可能会发现能够通过编译
//	而且能够正常使用，但不要认为这样写是正确的 
//	这是因为我们使用的编译器叫做gcc
//	这项功能是gcc编译器提供的扩展功能
//	它不是C++标准中规定的写法 
//	这个在做题目的时候一定要注意，尤其是选择题中 
//	能正常运行不等于正确！
//	
//	根据以上规则，我们可以得出一个结论：
//	（实际上也是一条规则） 
//	数组的长度在程序运行过程中是不变的
//	不能缩小，也不能增大
//	所以，在使用数组解决问题的时候
//	一定要先考虑清楚究竟需要多大的数组
//	我们创建数组的时候，只能根据较大的范围去创建
//	
//	使用数组：
//	1.要特别注意，我们平时所说的第1个元素
//	实际上在数组中，它是第0个元素
//	换句话说，数组中元素的编号是从0开始的
//	而不是从1开始的
//	例如，对于int a[5];这个数组
//	它包含的元素编号，分别为 0, 1, 2, 3, 4，一共5个元素
//	并不是1, 2, 3, 4, 5 
//	
//	我们可以通过这个编号，去直接访问这个位置的元素
//	int a[5] {7, 2, 1, 4, 6};
//	假设我们想要取出元素 4
//	那么我们需要使用索引运算符[]和元素4的编号
//	也就是 int b = a[3];
//	这样，我们就取出了元素4，并且赋值给了变量b
//	当然，虽然我们说是"取出"，但是实际上这个操作
//	只是获取它，并不会在数组中删除这个元素 
//	其中这个"编号"它正规的叫法应该是"索引"或"下标"
//	
//	简单的应用：利用for循环输出数组的所有元素
//	如果不初始化数组，那么其中的每一个元素的值是随机的
//	并不是声明之后就默认为0！
//	 
//	int b[20] {};
//	for (int i = 0; i < 20; ++i) {
//		cout << b[i] << ' ';
//	} 
//	
//	如何把一串数字输入进数组中：
//	第一步：创建一个足够大的数组
//		也就是说，数组的长度必须大于等于要输入的数字个数
//	第二步：输入
//		如果已知这串数字的个数n, 那么使用for循环比较好 
//		(假设n <= 20)
//		为了保证数组够大，我们可以将长度设为25
//		int a[25];
//		这样我们可以从下标为1的位置开始存储
//		也可以从下标为0的位置开始存储
//		下面就以下标为0开始存储举例 
//		for (int i = 0; i < n; ++i) {
//			cin >> a[i];
//		} 
//		然后 a[0] ~ a[n - 1] 是每个数对应的存储位置
//		
//		如果不知道这串数究竟有多少个
//		那么使用while循环比较好
//		int a[25];
//		这里我们需要自己创建一个变量去保存元素个数
//		同时它也担任着标记每个数下标的工作
//		int cnt = 0; <--- 保存元素个数(数组真实长度) 
//		while (cin >> a[cnt]) {
//			++cnt; 
//		} 
//		把cnt想象成一个指示存储位置的标记 
//		每输入一个数字，这个标记就向后移一格
//		使得下一个元素能够存储到下一个格子里
//		同样地，每个元素所处位置
//		也是a[0] ~ a[cnt - 1] 
//		
//		while (cin >> a[cnt]) 
//		
//		cin >> n 
//		cin 实际上是一个变量，>> 是一个运算符
//		所以cin >> n实际上是一个表达式
//		就类似 a + b 
//		既然是表达式，就会有一个结果
//		这个结果我们称为返回值
//		这个返回值是运算符的返回值
//		也就是说，a + b的结果是 + 运算符的返回值
//		同理，cin >> n的返回值是 >> 运算符的返回值
//		这个返回值就是 cin 本身
//		这也就是为什么我们可以连续写>>来进行输入
//		cin >> a >> b >> c
//		实际上它分3步
//		1. cin >> a，返回cin
//			原表达式变为cin >> b >> c
//		2. cin >> b，返回cin
//			原表达式就变为cin >> c
//		.... 
//		while (条件表达式) {
//			
//		} 
//		true false
//		a > b 
//		条件表达式：它的返回值是一个bool值
//		要么是true 要么是false
//		
//		假设我写一个整数进去，会发生什么？ 
//		这个整数会被隐式转换为bool值
//		整数的转换规则：
//		非0值全部转换为true
//		0 转换为false
//		
//		每一种数据类型都有它自己的转换规则
//		基本数据类型的转换规则都差不多
//		就是非0为true，0为false
//		
//		cin 它的类型不是基本数据类型，是"类"类型
//		因此它有自己独特的转换规则
//		可以这样理解： 
//		cin内部有一个标记，表示是否应该继续输入
//		如果这个标记被标为：不应该继续输入
//			那么cin被隐式转换为bool值的时候将会变为false
//			否则就会转换为true
//		
//		那么什么时候这个标记会被标为不应该继续输入？
//		1. 当读入的类型不符合目标变量的类型时
//			int a;
//			cin >> a;
//			假如输入是字符'x'，cin就不会将它输入 
//			int a;
//		cin >> a; 
//		cout << (int)'x' << '\n';
//		cout << a;
//		2. 当读入文件结束符时
//		在文件的末尾会有一个隐藏的符号，它的名字就叫
//		文件结束符
//		平时我们遇不到它，因为我们没有使用文件输入输出
//		但是在做题的网站上， 
//		判题系统会使用文件进行输入输出
//		所以会遇到文件结束符
//		
//		cin如果读到文件结束符，就会停止输入
//		int a;
//		while (cin >> a) {
//			cout << a << ' ';
//		}
//		按键盘上的Ctrl + Z 可以在控制台中打出文件结束符 
		
		int a[10];
		访问元素a[i]
		如果 i >= 10 我们称为下标越界
		这样的代码造成未定义行为，编译器不会检查
		所以不会报错，需要我们写程序的时候自己检查
		未定义行为，就是说没有规定编译器应该对它做什么， 
		编译器可以随意处理这段代码
		可以让它做一些事，也可以不让它做任何事
		也就说这段代码的作用是不确定的
		可以说未定义行为就是错误代码，不应该在程序中出现
		数组访问时，下标越界是典型的未定义行为
		必须时刻注意
		
		用const修饰的类型是常量类型
		常量类型的对象在声明时必须进行初始化
		否则编译器会报错
		常量对象一旦进行初始化，其值就再也不会被改变
		
		const int N = 5; 
		创建了名字为N的整型常量，其值为 5 
		5是常量表达式，因此 N 也是常量表达式 
}

