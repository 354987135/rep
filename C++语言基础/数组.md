# 内置数组
数组是一种连续的线性数据结构，能够保存多个相同类型的数据，此处我们并不讨论数组的数据结构性质，而是从 C++ 语言层面讨论与数组相关的语法和语义

不需要包含任何标准库头文件也可以使用的数组称为内置数组，也可以称为 C 语言数组或 C 风格数组，

需要注意的是，C语言数组变量之间是不能进行赋值的

在 C++ 中，数组的存储是行优先，例如二维数组，在内存中是先排列行的元素，再排列列的元素，多维数组实际上就是数组的数组


```cpp
int a1[5] {1, 2, 3, 4, 5};
int a2[5] = a1; // error
```
## 数组指针
当我们尝试将数组作为参数传递给函数时，可能会遇到一些问题，例如：

1. 为什么函数参数是指针类型，但可以将数组变量传递进去？
```cpp
void f1(int arr[]) { std::cout << arr[0] << '\n'; }
void f2(int* arr) { std::cout << arr[1] << '\n'; }
int main() {
    int a[3] {5, 3, 8};
    f1(a);
    f2(a);
}
// 输出  
//     5
//     5
```
2. 为什么可以使用`int* arr`作为参数类型并传递一维数组，但不能将参数设为`int**... arr`来传递多维数组？
3. 为什么可以使用`int[]`作为参数类型并传递一维数组，但不能将参数设为`int[][]...`来传递多维数组？
 
这一切都和数组指针有关，在了解这部分内容之前，我们首先要明确一些概念：
- “数组指针”是一类指针的名字，并不是“数组和指针”的意思
- 数组和指针是不同类型的对象，但对数组的所有操作都和指针密切相关

现在我们来对上面的问题进行解答：
1. 调用函数`f2(a)`时，数组`a`的类型被隐式转换为了`int*`
2. 一维数组`int[N]`可以隐式转换为`int*`类型，但多维数组不能隐式转换为`int**...`类型

数组指针，即指向数组的指针，下列代码中 $pta$ 就是一个指向一维数组的指针，可以指向不同的一维数组
```cpp
int arr9[8] {4, 1};
int arr10[10] {10, 102};
int (*pta)[];
pta = &arr9;
std::cout << (*pta)[0] << " " << (*pta)[1] << "\n";
// 输出 4 1
pta = &arr10;
std::cout << (*pta)[0] << " " << (*pta)[1] << "\n";
// 输出 10 102
```
如果在 $[]$ 内指定元素个数 $x$，那么这个数组指针就只能指向包含 $x$ 个元素的一维数组，但现在它既可以指向一维数组，又可以指向二维数组，因为二维数组也可以看成是包含 $x$ 个数组元素的一维数组
```cpp
int arr11[15] {3, 2};
int arr12[5] {3, 4, 6};
int arr13[20][5];
arr13[10][3] = 555;
int (*pta2)[5];

// pta2 = &arr11;
// 编译错误

pta2 = &arr12;
std::cout << (*pta)[0] << " " << (*pta)[1] << "\n";
```
```cpp
void print_1d_arr1(int arr[]) {
    for (int i = 0; i < 5; i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
}//参数类型会隐式转换为int*

void print_1d_arr2(int* arr) {
    for (int i = 0; i < 5; i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
}//参数直接写int*

void print_2d_arr1(int (*arr)[2]) {
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            std::cout << arr[i][j] << " ";
        }
        std::cout << "\n";
    }
    std::cout << "\n";
}//二维数组的传参，使用数组指针，此处[]内必须指定长度

void print_2d_arr2(int arr[][2]) {
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            std::cout << arr[i][j] << " ";
        }
        std::cout << "\n";
    }
    std::cout << "\n";
}//二维数组的传参，使用数组形式，必须指定第二个[]的长度，和声明二维数组一样

int main() {
    int arr8[8] {};

    //声明数组指针，即指向数组的指针，pta是一个指向int[10]数组的指针
    pta = &arr10;
    //把arr10的地址赋给pta
    //pta = &arr8;
    //编译错误，指针pta只能指向长度为10的int数组
    std::cout << (*pta)[0] << " " << (*pta)[1] << "\n";
    //输出数组arr10的第一个元素10和第二个元素102，此处[]运算符优先级高于*运算符，必须加括号
    std::cout << pta << " " << pta + 1 << "\n";
    //对于pta来说，+1每次就向后移动10 * sizeof(int)个字节

    int arr11[5] { 4, 3, 2, 3, 9 };
    int arr12[2][2] { { 4, 8 }, { 3, 6 } };
    print_1d_arr1(arr11);
    print_1d_arr2(arr11);
    print_2d_arr1(arr12);
    print_2d_arr2(arr12);
}
```
# 多维数组映射函数
我们已经知道，无论是一维数组还是多维数组，本质上都是一块连续的内存，那么我们可以用一维数组和特定的映射函数来实现多维数组

用途：`std::vector<std::vector>`这样的写法通常是效率低下的，因为多个std::vector的内存之间可能并不连续，通过映射函数，我们就可以把它定义为一维的std::vector

假设我们有 `an[N1][N2][N3][N4]...[Nn]` 这个 n 维数组，将其化为一维数组就是`a1[N1*N2*N3*N4*...*Nn]`
那么如果我们要取`an[i1][i2][i3][i4]...[in]`，在一维数组中就需要一定的映射关系，我们可以编写一个定位函数

```cpp
int a[5][6][7][8][9];
a[1][4][2][7][3] = 111;

int b[5 * 6 * 7 * 8 * 9];
constexpr int index = 
      1 * 6 * 7 * 8 * 9 
    + 4 * 7 * 8 * 9 
    + 2 * 8 * 9
    + 7 * 9
    + 3;

std::cout << sizeof a << ' ' << sizeof b << '\n';
std::cout << &a[1][4][2][7][3] - &a[0][0][0][0][0] << '\n';
std::cout << &b[index] - &b[0] << '\n';
```
从这段代码中我们可以观察到，数组a和b的大小相同，并且b[index]的位置和a[1][4][2][7][3]的位置是对应的，因为它们与首元素之间的偏移值是相同的，因此我们可以得到这个映射关系

假设要在一维数组中取a[k1][k2][k3]...[kn], 那么它的下标计算方式如下
$$
GetIndex(t_1, t_2... t_n) = \sum_{i=1}^{n-1}{t_i\prod_{j=i+1}^n{k_j}} + t_n
$$
```cpp
int GetIndex(int ...) {
    可变参数...
}
```
# `std::array`容器
https://en.cppreference.com/w/cpp/header/array

C语言数组在使用时几乎总会退化为指针，下标运算实际上等价于指针的偏移运算，你可以写arr[N]，还可以写N[arr]，很明显这在数组语义上看起来非常奇怪，而std::array就不会有这样的问题，不会退化为指针

std::array，可以把它当作一个只包含数组的结构体，它不会退化为指针，也不会支持N[arr]这种写法，并且std::array对象还可以互相进行赋值
```cpp
struct array {
    T arr[N]
}
```
# `std::vector`容器
动态数组 vector

https://en.cppreference.com/w/cpp/header/vector