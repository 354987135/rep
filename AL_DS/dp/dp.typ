#set text(font: ("Linux Libertine", "Noto Sans SC"), size: 12.5pt)

#show raw: set text(font: ("Fira Code", "Noto Sans SC"), features: (calt: 0), lang: "cpp")


#show raw.where(block: false, lang: "cpp"): box.with(
  fill: luma(240),
  inset: (x: 2pt, y: 0pt),
  outset: (y: 3pt),
  radius: 2pt
)

// #show heading.where(): set heading(numbering: "1.")

#let spacing = h(0.25em, weak: true)
#show math.equation.where(block: false): it => spacing + it + spacing

= 动态规划的基本概念
动态规划是一种解决问题的思想，其核心是通过记录子问题答案的方式避免对重叠子问题的反复计算，从而降低计算的总时间开销，也就是“利用空间换时间”，常用于解决最优化问题、计数问题、存在性问题，在这些问题中，我们只需要知道结果是什么，而不需要知道中间过程具体是怎样的

动态规划并不关心得到问题答案的具体方案，而是关心每个问题答案与它子问题的答案之间有什么联系，这实际上隐含了对枚举树的剪枝操作，这是动态规划算法比蛮力枚举高效的另一个原因

在动态规划的语境下，问题本身的答案及其所有子问题的答案叫做“状态”，通过递推式描述的、答案之间的联系叫做“状态转移方程”，动态规划的过程就是利用初始状态和状态转移方程进行自底向上的递推，并得到问题的所需的状态

一个问题只有在满足以下条件时，才能够利用动态规划解决
1. 可以被分解为相同且规模更小的子问题
2. 具有最优子结构
问题的最优解可以由其子问题的最优解得到
3. 子问题具有重叠性
例如斐波那契数列
4. 状态具有无后效性
若某个状态已知，那么该状态的后续状态只与该状态有关，而与当前状态之前的状态无关，这被称为动态规划的无后效性，简单来说，就是未来状态由当前状态决定，与过去状态无关，动态规划要求按顺序且不重复地计算每一个状态，因此必须满足无后效性

举一个具体的例子，某人需要到达A点，至于他是走直路到的，还是弯曲到的，这与在A点接他的人无关，接他的人是否接到某人，只取决于他是否到达A点，不取决于他使用什么方式到达A点
= 利用动态规划解决问题的基本步骤
1. 设计状态，并用`dp`数组描述
2. 确定状态转移方程
3. 确定初始状态
4. 根据状态转移方程和问题的约束条件，从初始状态开始递推并更新`dp`数组
5. 从`dp`数组中取出答案
6. 尝试从空间、时间上进一步优化已设计的动态规划算法
= 常见的动态规划问题模型
== 线性DP
线性DP，即状态转移方程为特定变量的线性函数的DP问题，
=== 一维线性DP
=== 爬楼梯
=== 最长上升子序列 (LIS)

=== 最长公共子序列 (LCS)

=== 背包DP
=== 0-1背包问题
==== 问题描述
有$n$种物品，每种物品都有自己的重量$w$和价值$v$，且数量只有$1$个，用一个负重限制为$m$的背包装载物品，问能取得的价值最大为多少？
==== 状态分析
令`dp[i][j]`表示的状态为：对前```cpp i```个物品，使用```cpp j```个单位的背包负重，能取得的最大价值

对于第```cpp i```个物品来说，前`i - 1`个物品已经考虑完毕，此时有装与不装两种选择，如果不装，那么使用的背包负重在考虑第```cpp i```个物品前后并未改变，均为`j`，且背包中物品的最大价值相比只考虑前`i - 1`个物品时也没有改变，因此状态转移方程为`dp[i][j] = dp[i - 1][j]`；如果装，那么在考虑第`i`个物品后，使用的背包负重`j`中包含了第`i`个物品的重量```cpp w[i]```，考虑之前使用的背包负重应为`j - w[i]`，最大价值相比考虑之前增加了第`i`个物品的价值`v[i]`，因此状态转移方程为`dp[i][j] = dp[i - 1][j - w[i]] + v[i]`，显然，若当前背包空间`j < w[i]`，则无法选择装物品`i`

综上所述，该问题的状态转移方程为
```cpp 
dp[i][j] = j < w[i] ? dp[i - 1][j]
    : std::max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])
```
==== 边界条件分析
若背包负重为$0$，则显然最大价值为$0$，即`dp[i][0] = 0`；若不选任何物品，则最大价值也为$0$，即`dp[0][j] = 0`
==== 0-1背包问题的优化

=== 完全背包问题
==== 问题描述
在0-1背包问题的基础上，将每种物品数量改为无限个
