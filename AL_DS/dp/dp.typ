#set text(font: ("Linux Libertine", "Noto Sans SC"), size: 12.5pt)

#show raw: set text(font: ("Fira Code", "Noto Sans SC"), features: (calt: 0), lang: "cpp")


#show raw: box.with(
  fill: luma(240),
  inset: (x: 2pt, y: 0pt),
  outset: (y: 3pt),
  radius: 2pt
)

#show raw.where(block: false, lang: "cpp"): box.with(
  fill: luma(240),
  inset: (x: 2pt, y: 0pt),
  outset: (y: 3pt),
  radius: 2pt
)

// #show heading.where(): set heading(numbering: "1.")

#let spacing = h(0.25em, weak: true)
#show math.equation.where(block: false): it => spacing + it + spacing

#import "@preview/codly:1.0.0"

#codly.codly(
  languages: (
    cpp: (
      name: "C++",
      // icon: text(font: "tabler-icons", "\u{fa53}"),
      color: rgb("#283FC1")
    ),
  )
)

#codly.codly(
  stroke: 1pt + gradient.linear(..color.map.flare),
)

#show: codly.codly-init.with();

= 认识动态规划
== 抽象概念
动态规划是一种算法设计思想，其核心是记录子问题答案，避免反复计算重叠子问题，从而降低蛮力枚举算法的计算时间，俗称“空间换时间”，常用于解决只需要知道结果，而不需要知道具体中间过程的问题，例如：组合优化问题、存在性问题，因为动态规划并不关心得到问题答案的具体方案，而是关心每个问题的答案与它子问题的答案之间有什么联系

在动态规划的语境下，问题的答案叫做*状态*，通过递推式描述的、答案之间的联系叫做*状态转移方程*，动态规划的实现过程就是利用初始状态和状态转移方程进行自底向上的递推，并达到目标状态，这一过程自然包含了对枚举树大量无效分支的剪枝操作，使得动态规划算法通常能够在多项式时间内解决问题

一个问题只有满足下列条件1，2，3时，才能够利用动态规划解决，满足条件4时，动态规划才能显著降低计算时间
1. 可以被分解为相同且规模更小的子问题

2. 具有最优子结构：问题的最优解可以由其子问题的最优解得到

3. 状态系统具有无后效性：在已知当前状态的前提下，未来某个状态只与当前状态，以及该未来状态所处阶段有关，与过去状态无关，也就是说，过去状态和未来状态不会相互影响

  动态规划算法在递推时要求按顺序且不重复地计算每一个状态，因此必须满足无后效性

4. 子问题具有重叠性：存在大量需要被重复计算的子问题
== 具体例子
问题：求斐波那契数列的第$n$项

根据斐波那契数列的递推式$f(n)=f(n-1)+f(n-2), f(1)=1, f(2)=1$，可以写出下列递归代码求解该问题
```cpp
int f(int n) {
    return n < 3 ? 1 : f(n - 1) + f(n - 2);
}
```
该代码的递归树如下

根据递归树可知，该算法的时间复杂度为$O(2^n)$，容易看出，递归求解时对大量节点做了重复计算，这是导致该算法低效的原因
= 利用动态规划解决问题的基本步骤
1. 设计状态，并用`dp`数组描述
2. 确定状态转移方程
3. 确定初始状态
4. 根据状态转移方程和问题的约束条件，从初始状态开始递推并更新`dp`数组
5. 从`dp`数组中取出答案
6. 尝试从时间、空间上进一步优化已设计的动态规划算法
= 常见的动态规划问题模型
== 线性DP问题
若某DP问题的状态转移方程仅包含线性运算，则称之为线性DP问题，其中具有一定特征的问题又可以被细分为特殊模型
=== 一维线性DP问题
如果某问题的状态对应的`dp`数组是一维数组，那么称该问题为一维线性DP问题
==== 凑钱问题
===== 问题描述
给定$n$个数，分别为$n$种硬币各自的面额，每种硬币有无限个，问凑成钱数$S$最少需要使用多少枚硬币？
===== 状态分析
设状态`dp[i]`表示：凑成钱数`i`需要使用的硬币的最少数量
===== 相关习题
1. https://www.luogu.com.cn/problem/B3635
2. https://leetcode.cn/problems/coin-change/
==== 最长上升子序列问题
===== 问题描述
给定长度为$n$的数列（不要求有序），

===== 优化
===== 扩展内容
狄尔沃斯定理：在有限偏序集中，包含链数最少的链分解的链数等于包含元素最多的反链的元素个数

应用到此处可以得到：数列中，最长不升子序列的数量等于最长上升子序列的长度
=== 二维线性DP问题
如果某问题的状态对应的`dp`数组是二维数组，那么称该问题为二维线性DP问题
==== 最长公共子序列问题
===== 问题描述
===== 状态分析
设状态`dp[i][j]`表示：序列$a$的前`i`个字符与序列$b$的前$j$个字符的最长公共子序列长度

遍历序列，讨论序列$a$与$b$的末尾元素是否相等，如果相等，说明元素是公共子序列中的一个元素，`dp[i][j] = dp[i - 1][j - 1] + 1`，如果
==== 0-1背包问题
===== 问题描述
有$n$种物品，每种物品都有自己的重量$w$和价值$v$，且数量只有$1$个，用一个负重限制为$m$的背包装载物品，问能取得的价值最大为多少？
===== 状态分析
设状态`dp[i][j]`表示：考虑`i`号及其之前的所有物品，使用不超过`j`个单位的背包负重，能取得的最大价值

对于`dp[i][j]`这一状态来说，前`i - 1`个物品已经考虑完毕，此时第`i`号物品有选与不选两种选择，如果不选，那么使用的背包负重和获取的最大价值在考虑第`i`号物品前后并未改变，状态转移方程为`dp[i][j] = dp[i - 1][j]`；如果选，那么在选完第`i`号物品后，使用的背包负重`j`中包含了第`i`号物品的重量`w[i]`，因此选之前使用的背包负重为`j - w[i]`，最大价值相比选之前增加了第`i`号物品的价值`v[i]`，状态转移方程为`dp[i][j] = dp[i - 1][j - w[i]] + v[i]`

当背包空间`j < w[i]`时，不能选，当背包空间`j >= w[i]`时，可以选也可以不选，需要比较哪个情况更优，取较大值完成状态转移

初始状态：若背包负重为$0$，则无法装入任何物品，最大价值为$0$，即`dp[i][0] = 0`；若不选任何物品，则最大价值也为$0$，即`dp[0][j] = 0`

代码实现
```cpp
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
        if (j < w[i]) {
            dp[i][j] = dp[i - 1][j];
        } else {
            dp[i][j] = std::max(dp[i - 1][j],
                dp[i - 1][j - w[i]] + v[i]);
        }
    }
}
```
===== 优化
0-1背包问题的时间复杂度为$O(m n)$，空间复杂度为$O(m n)$，通常不考虑时间上的优化，空间可优化为$O(m)$，下面是空间的优化方法

由状态转移方程可知，求`dp[i][j]`只需要知道它的上一行，即`i - 1`行，之前的行都是冗余的，利用滚动数组思想，可以将`[i]`这个维度去掉，使用一维`dp`数组完成递推，令`dp[j]`表示：使用不超过`j`个单位的背包负重，能取得的最大价值

如果把递推时的循环变量`j`看作分割线，那么如图...所示，`dp`数组中未被`j`扫过的格子代表未更新的状态，对应于二维`dp`数组中上一行的状态，被`j`扫过的地方代表已更新的状态，对应于二维`dp`数组中当前行的状态

采用一维数组优化后，不选`i`号物品的情况下，`dp`数组不需要改变，自动继承对应于二维`dp`数组中上一行的`dp[i - 1][j]`状态，状态转移方程为`dp[j] = dp[j]`；选`i`号物品的情况下，上一个状态对应于二维`dp`数组中上一行的`dp[i - 1][j - w[i]]`状态，状态转移方程为`dp[j] = dp[j - w[i]] + v[i]`

显然，`dp[j - w[i]]`位于`dp[i]`的左侧，要使计算`dp[j]`时使用的状态对应于二维`dp`数组中第`i - 1`行的状态，与二维状态转移方程保持一致，必须从右向左递推

代码实现
```cpp
for (int i = 1; i <= n; ++i) {
    for (int j = m; j >= w[i]; --j) {
        dp[j] = std::max(dp[j],dp[j - w[i]] + v[i]);
    }
}
```
==== 完全背包问题
===== 问题描述
在0-1背包问题的基础上，将每种物品的数量改为无限个
===== 状态分析
状态设计与0-1背包问题相同

在完全背包问题中，对于`i`号物品考虑的是选$0$个与选$>=1$个两种情况，选$0$个相当于没有考虑`i`号物品，状态转移方程为`dp[i][j] = dp[i - 1][j]`；选$>=1$个的情况下，如果`i`号物品不是第一次被选，那么在此之前`i`号已被考虑，状态转移方程为`dp[i][j] = dp[i][j - w[i]] + v[i]`，如果是第一次选，那么状态转移方程为`dp[i][j] = dp[i - 1][j - w[i]] + v[i]`

实际上，并不需要单独考虑第一次选`i`号物品的情况，因为当`j < w[i]`时，不能选择`i`号物品，`dp[i][j]`总是等于`dp[i - 1][j]`，相当于复制了一遍，使得第一次选择`i`号物品时，状态转移所需的`dp[i - 1][j - w[i]]`，必然也存等于`dp[i][j - w[i]]`，因此，选$>=1$个时，状态转移方程为`dp[i][j] = dp[i][j - w[i]] + v[i]`

与0-1背包问题类似，当`j >= w[i]`时，需要在`dp[i][j - w[i]] + v[i]`与`dp[i - 1][j]`之间取较大值完成状态转移

初始状态与0-1背包问题相同

代码实现
```cpp
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= m; ++j) {
        if (j < w[i]) {
            dp[i][j] = dp[i - 1][j];
        } else {
            dp[i][j] = std::max(dp[i - 1][j],
                dp[i][j - w[i]] + v[i]);
        }
    }
}
```
===== 优化
与0-1背包问题相似，唯一的区别在于递推时应该从左向右递推，使得计算每个`dp[j]`时使用的都是对应于二维`dp`数组中第`i`行的状态，与二维状态转移方程保持一致

代码实现
```cpp
for (int i = 1; i <= n; ++i) {
    for (int j = w[i]; j <= m; ++j) {
        dp[j] = std::max(dp[j],dp[j - w[i]] + v[i]);
    }
}
```
=== $n$维线性DP问题$(n > 2)$
