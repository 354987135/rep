# 冒泡排序
现假设目标顺序是升序，则冒泡排序的算法描述如下：

以下标$i$为边界，每次选定序列中一个$[0, i]$范围，在选定范围中，以下标$j$表示当前元素，从第一个元素开始，不断比较相邻两个元素，若左侧元素大于右侧元素，则交换它们，直到所有相邻元素都被比较过，此时，该选定范围内的最大元素一定会移动到下标为$i$的位置

使得最大的元素从原始位置逐渐移动到该范围的最右侧，然后最右侧的部分就是有序序列，下一次选定范围时可以缩小范围，不包含这些已有序的元素，重复这一过程

代码实现如下：
```cpp
void BubbleSortBasic(vector<int>& arr) {
    for (int i = arr.size() - 1; i >= 0; --i) {
        for (int j = 0; j < i; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```
其中外层循环的 i 表示每次选定的范围的右端点的下标，j 表示当前需要比较选定范围中的第 j + 1 个数和第 j + 2 个数

该代码是未经优化的冒泡排序，在任意情况下，每次都需要两两比较范围中的所有数，因此时间复杂度为$O(n^2)$

优化方法是使用一个 bool 值标记某个范围内是否产生过交换，如果未进行交换，则代表序列已经有序，在最好情况下，即输入序列本身就符合要排的顺序，则该算法在第一个范围内（就是完整的序列）即可确定整个序列有序，此时时间复杂度为$O(n)$

优化后的代码如下

```cpp
void BubbleSort(vector<int>& arr) {
    bool sorted = true;
    for (int i = arr.size() - 1; i >= 0; --i) {
        for (int j = 0; j < i; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                sorted = false;
            }
        }
        if (sorted) {
            return;
        }
    }
}
```
总结：

冒泡排序是稳定的排序方法，因为冒泡排序基于序列中相邻两元素的比较和交换，因此，如果要让相同元素的相对顺序发生改变，那么只能是这两个元素相邻时进行交换，而冒泡排序中交换的条件是两元素不相等

其最好情况下时间复杂度为$O(n)$（优化后，数组一开始就有序的状态），最坏及平均时间复杂度为$O(n^2)$
# 选择排序
现假设要求序列按升序排列，则选择排序的基本思想如下：

选定数组最左侧的一个数，假设它为数组中最小的元素，然后将它右侧的每个元素与该元素依次比较，寻找是否有比它更小的数，若有，则交换两数，使得更小的元素处于最左侧，将右侧数全部扫描一遍后，最左侧的部分就是有序序列，下一次选定该有序序列右侧的第一个元素，重复这一过程

代码实现如下：
```cpp
void SelectionSort(vector<int>& arr) {
    for (int i = 0; i < arr.size(); ++i) {
        for (int j = i + 1; j < arr.size(); ++j) {
            if (arr[i] > arr[j]) {
                swap(arr[i], arr[j]);
            }
        }
    }
}
```
其中外层循环的 i 表示当前选定的最小数的下标，j 表示当前正在比较的右侧数的

选择排序是不稳定的排序方法，其时间复杂度总为$O(n^2)$
# 插入排序
插入排序的基本思想如下(升序排序)：

在序列左侧选定一个有序范围，初始时只包含一个元素，即最左侧元素，然后在剩下的范围中每次选择有序范围右侧的第一个元素，从右往左将其与有序范围中的元素依次进行比较、交换，直到遇到一个小于等于它的元素，此时该元素就到达了它应该在的位置，重复此过程，直到序列有序

代码实现如下：
```cpp
void InsertionSort(vector<int>& arr) {
    // i 的含义是当前选定的范围的右边界下标
    for (int i = 0; i < arr.size() - 1; ++i) {
        // j 的含义是当前元素的下标
        for (int j = i + 1; j > 0; --j) {
            if (arr[j - 1] > arr[j]) {
                swap(arr[j - 1], arr[j]);
            } else {
                break; // 当发现当前元素大于等于左侧第一个元素时
                // 说明当前元素已经在它该在的位置了
            }
        }
    }
}
```

插入排序是稳定的排序算法，其最好情况下（序列本身就有序，每次插入都只需要一次比较，总共需要$n - 1$次比较就可以完成插入排序）时间复杂度是$O(n)$，平均和最坏时间复杂度为$O(n^2)$
# 归并排序
归并排序的基本思想如下(升序排序)：

要求整个数组有序，可以先将数组分为左右两半，使得左右两半先分别有序，要使其左右两半分别有序，则应当递归利用同样的方法，最终，每个范围被分割至最小，即每个范围只包含单个元素，此时在范围内元素必然有序

之后将左右两半合并为一个有序的数组，并最终合并为完整的数组，合并过程中需要借助一个额外数组，因此其空间复杂度为O(n)

代码实现如下：
```cpp
void MergeSort(vector<int>& arr, int l, int r) {
    if (l >= r) {
        return;
    }
    int mid = (l + r) / 2;
    MergeSort(arr, l, mid);
    MergeSort(arr, mid + 1, r);
    // 合并
    vector<int> temp;
    int i = l, j = mid + 1;
    while (i <= mid && j <= r) {
        if (arr[i] <= arr[j]) {
            temp.push_back(arr[i++]);
        } else {
            temp.push_back(arr[j++]);
        }
    }
    while (i <= mid) {
        temp.push_back(arr[i++]);
    }
    while (j <= r) {
        temp.push_back(arr[j++]);
    }
    for (int i = 0; i < temp.size(); ++i) {
        arr[l + i] = temp[i];
    }
}
```
归并排序是稳定的排序方法，其时间复杂度总为$O(nlogn)$
# 快速排序
现假设要求序列按升序排列，则快速排序的基本思想如下：

选定待排序范围中的一个元素作为分组的标志，记为P，将数组划分为 < P, = P, > P的三个范围，= P的范围是有序的，然后对< P, > P的两个范围递归执行上述操作，逐渐从中间向两边完成排序

现在选择最右侧的元素为标志，开始时，< P 范围内不存在元素，其左边界下标为 0，右边界下标记为r1，开始时r1 = -1，将 P 放入 > P 范围内，> P 范围的右边界下标为数组的最大下标 n - 1，左边界记为r2，开始时是 n - 2

从< P范围的右边一个元素开始向右遍历，代表当前元素的下标记为 i，执行以下 3 个分支：

1. 若arr[i] < P, 将arr[i]与< P区域的右侧第一个元素arr[r1 + 1]交换，然后扩大< P区域，即r1++, 然后 i 移动到下一个元素
2. 若arr[i] == P, 直接将 i 移动到下一个元素
3. 若arr[i] > P, 将arr[i]与> P区域的左侧第一个元素arr[r2 - 1]交换，然后扩大> P区域，即r2--，i 保持不动
当 i == r2 时，停止遍历，并将 P 与arr[r2]交换

对< P范围和 > P范围递归执行上述操作

快速排序是不稳定的排序算法，例如对于序列 $4, 4, 3$, 选定最右的 $3$ 为基准数，则第一次比较时，第一个 4 需要与 第二个 4交换，破坏了两个 4 原有的先后顺序

快速排序的平均时间复杂度是$O(nlogn)$，最坏情况，即，时间复杂度会变成$O(n^2)$

代码实现如下：
```cpp
void QuickSort(vector<int>& arr, int l, int r) { // 0, size - 1
    // 选定最右元素为基准值
    if (l >= r) {
        return;
    }
    int lessR = l - 1, greaterL = r, cur = l;
    while (cur < greaterL) { // P = arr[r]
        if (arr[cur] < arr[r]) {
            swap(arr[cur++], arr[++lessR]);
        } else if (arr[cur] > arr[r]) {
            swap(arr[cur], arr[--greaterL]);
        } else {
            ++cur;
        }
    }
    swap(arr[greaterL], arr[r]);
    QuickSort(arr, l, lessR);
    QuickSort(arr, greaterL + 1, r);
}
```