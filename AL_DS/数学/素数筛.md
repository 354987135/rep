# 为什么要使用素数筛法
如果要计算[2, n]之间有多少个素数，最朴素的办法是判定每个数的素性，但这样显然开销太大，素数筛法就是为了解决这样的问题
# 埃氏筛法
遍历从[2, n]的每个数，如果其未被标记，则是素数，否则为合数，当 i 为素数时，要划掉所有 i 的倍数，算法结束后，未被标记的数必然就是素数
划掉素数时为什么要从 i * i 而不是 i + i 开始？因为小于它的合数已经被更小的素数划掉了，例如 2i 必然已被素数 2 划掉，3i必然已被 3 划掉...，最小的未被划掉的合数就是 i * i，这样可以减少一定的运算次数
```cpp
vector<int> EratosthenesSieve(int N) {
    vector<bool> vis(N + 1);
    vector<int> prime;
    for (int i = 2; i <= n; ++i) {
        if (!vis[i]) {
            prime.push_back(i);
        }
        for (int j = i * i; j <= n; j += i) {
            vis[j] = true;
        }
    }
    return prime;
}
埃氏筛法的时间复杂度为O(nloglogn)
```
# 线性筛法
埃氏筛法的过程中不可避免地会重复划掉合数，那么能否让每个合数都只被划去一次？根据算术基本定理，每个合数都必然含有至少一个素因子，设其为p，那么，只要让每个合数只被其最小的素因子划掉，所有合数就只会被划掉一次

不论i是素数还是合数，当 i % prime[j] == 0 时，i * prime[j + 1] 及后续的数中必然包含 prime[j] 这个最小的素因子，所以后面不需要再继续遍历

进行改进后，可以得到时间复杂度为O(n)的线性筛
```cpp
vector<int> LinearSieve(int N) {
    vector<bool> vis(N + 1);
    vector<int> prime;
    for (int i = 2; i <= N; ++i) {
        if (!vis[i]) {
            prime.push_back(i);
        }
        for (int j = 1; j < len && i * prime[j] <= N; ++j) {
            vis[i * prime[j]] = 1; // 通过最小素因子划掉可能的合数
            if (i % prime[j] == 0) {
                break;
            }
        }
    }
    return prime;
}
```