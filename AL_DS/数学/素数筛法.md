# 问题引入
如果要计算区间$[2, n]$上有多少个素数，或是制作一张区间$[2, n]$上的素数表，最朴素的办法是遍历区间上的所有整数并判断每个整数是否为素数，但这样的方法在时间开销上显然不够优秀，使用素数筛法可以快速地完成这类任务
# 埃氏筛法
使用`vis`数组作为数表记录一个数是否还在表上，对于区间$[2, n]$上的每个整数 $i$，如果`vis[i] == true`，则 $ i $ 已被划掉，即 $i$ 为合数，否则未被划掉，为素数，初始时假设所有数都是素数

遍历数表遇到素数 $i$ 时，在数表上从 $i * i$ 开始划掉所有 $i$ 的倍数，遍历完区间上的所有整数后，数表中剩下的数就是素数

划掉素数时为什么要从 $i * i$ 开始而不是 $i + i$ 开始？这便是埃氏筛法的核心，对于任意一个素数 $i$ 来说，小于 $i * i$ 的合数都已经被比 $i$ 更小的素数划掉了，例如 $i + i$ 必然已被素数 $2$ 划掉，$i + i + i$ 必然已被 $3$ 划掉等等，最小的未被划掉的合数就是 $i * i$，因为其不含有小于 $i$ 的素因子，这样使得最终的时间复杂度为 $O(nloglogn)$，大约相当于 $O(n)$ 的最高次项乘了一个较小的常数，非常接近 $O(n) $复杂度

注意点：

- 对于`int`范围内的 $N$，$i * i$ 可能会超过`int`的最大值，需要将其转换为`long long`防止溢出
```cpp
vector<int> EratosthenesSieve(int N) {
    vector<bool> vis(N + 1);
    vector<int> prime;
    for (int i = 2; i <= N; ++i) {
        if (!vis[i]) {
            prime.push_back(i);
            for (long long j = 1LL * i * i; j <= N; j += i) {
                vis[j] = true;
            }
        }
    }
    return prime;
}
```
# 线性筛法
埃氏筛法对重复划掉合数的次数进行了优化，但不能完全避免重复划掉合数，那么能否让每个合数都只被划去一次，使得筛法的复杂度变为 $O(n)$？根据算术基本定理，每个合数都必然含有至少一个素因子，设合数中最小的素因子为 $p$，那么，只要让每个合数只被 $p$ 划掉，所有合数就只会被划掉一次

如何实现呢？对于区间$[2, n]$上的每个整数 $i$，不论 $i$ 是素数还是合数，都将其与已知的素数从小到大相乘，得到新的合数并划掉，当遍历到能够整除 $i$ 的已知素数时，停止划数，这是因为，如果i 包含 prime[j] 这个最小素因子，因此 i * prime[j + 1] 及后续的数中也必然包含 prime[j]，它们都可以被后续遍历到的合数筛掉，所以此时需要停止遍历 prime[j]必然能与一个更大的素数或合数结合成该数

注意点：

- 与埃氏筛法中类似，对于`int`范围内的 $N$，$i$ 乘上某个素数的积可能会超过`int`的最大值，需要将其转换为`long long`防止溢出

- 循环中间条件不需要加`j < prime.size()`来避免越界，这是因为，如果 $i$ 是素数，那么循环达到`break`时，`j`至多枚举到`prime`数组中的最后一个元素（即 $i$ 自身），不会越界，如果 $i$ 是合数，那么根据算术基本定理，$i$ 中必然存在至少一个素因子 $p < i$，并且，根据素数筛法从小到大筛选的性质，此 $p$ 必然存在于`prime`数组内，在循环达到`break`之前，`j`也不会越界
```cpp
vector<int> LinearSieve(int N) {
    vector<bool> vis(N + 1);
    vector<int> prime;
    for (int i = 2; i <= N; ++i) {
        if (!vis[i]) {
            prime.push_back(i);
        }
        for (int j = 0; 1LL * i * prime[j] <= N; ++j) {
            vis[i * prime[j]] = true;
            if (i % prime[j] == 0) {
                break;
            }
        }
    }
    return prime;
}
```