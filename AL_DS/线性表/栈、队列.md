# 栈的基本概念
栈是一种操作受限的线性表，其限制为：插入、删除操作在表的同一端进行，这一端称为“栈顶”，插入操作称为“入栈”，删除操作称为“出栈”，不进行操作的另一端称为“栈底”，由此可以得出，元素的出栈顺序和入栈顺序是相反的，称为“先进后出 ( FILO, First In Last Out )”
# 栈的表示和存储
## 数组模拟
使用一个足够大的数组`stack[N]`存储元素，设置变量`top`表示栈顶，称为栈顶指针，它保存栈顶元素的下标，起始值为 0，通过`top`的运算就可以实现栈的操作
## 链表模拟
使用单链表`stack`存储元素，单链表的头部为栈顶，尾部为栈底，通过单链表在头部的插入、删除实现栈的操作
# 栈的基本操作
单链表的操作参见链表章节，此处使用数组实现各基本操作
```cpp
// 判定栈是否为空
top == 0;
// 判定栈满
top == N;
// 清空栈
top = 0;
// 获取栈中元素的个数
top;
// 获取栈顶元素
stack[top - 1];
// 元素入栈
stack[top] = x;
++top;
// 元素出栈
--top;
```
# 单调栈

# 队列的基本概念
队列是一种操作受限的线性表，其限制为：插入、删除操作在表的不同端进行，其中插入端称为“队尾”，插入操作称为“入队”；删除端称为“队首”，删除操作称为“出队”，由此可以得出，元素的出队顺序和入队顺序是相同的，称为“先进先出 ( FIFO, First In First Out )”
# 队列的表示和存储
## 数组模拟
使用一个足够大的数组`queue[N]`存储元素，设置变量`front`表示队首，称为队首指针，它保存队首元素前一位置的下标，起始值为 0；设置变量`rear`表示队尾，称为队尾指针，保存队尾元素的下标，起始值为 0，通过`front`和`rear`的运算就可以实现队列的操作
## 链表模拟
使用单链表`queue`存储元素，单链表的头部为队首，尾部为队尾，给单链表额外设置一个尾指针，通过单链表在头部的删除（头指针实现）、尾部的插入（尾指针实现），实现队列的操作
# 队列的基本操作
单链表的操作参见链表章节，此处使用数组实现各基本操作
```cpp
// 判定队列是否为空
front == rear;
// 判断队列是否为满
rear == N;
// 清空队列
front = 0;
rear = 0;
// 获取队列中元素的个数
rear - front;
// 获取队首元素
queue[front];
// 元素入队
queue[rear] = x;
++rear;
// 元素出队
++front;
```
# 循环队列
由于队列的首尾指针都只有 + 运算，因此在不断入队、出队的过程中，空间会逐渐变小，当判断到队满时可能还有空间可以存储元素，这种现象称为 “假溢出”，循环队列可以解决假溢出的问题
## 循环队列的基本操作
```cpp
// 判断队空
rear == front
// 判断队列为满
少用一个元素的存储空间，有N - 1个元素时就认为队满，判定条件如下
(rear + 1) % N = front;
// 入队
queue[rear] = x;
rear = (rear + 1) % N;
// 出队
front = (front + 1) % N;
// 获取元素数量
(rear - front + N) % N;
也可以额外设置一个变量 size 保存元素的数量

size还可以用于判定循环队列是否为满 (size == N)
而不需要再保留一个空位
```
### 单调队列

### 双端队列
可以在两端进行常数时间插入删除操作的线性表，相当于队列和栈的结合

deque 容器

https://en.cppreference.com/w/cpp/header/deque

该容器还支持下标运算，随机存取