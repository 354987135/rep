# 冒泡排序
现假设要求序列按升序排列，则冒泡排序的基本思想如下：

选定数组中的一个范围，在范围中不断比较相邻元素，若左侧元素大于右侧元素，则交换相邻的元素，使得最大的元素从原始位置逐渐移动到该范围的最右侧，然后最右侧的部分就是有序序列，下一次选定范围时可以缩小范围，不包含这些已有序的元素，重复这一过程

代码实现如下：
```cpp
void BubbleSort(vector<int>& arr) {
    for (int i = arr.size() - 1; i >= 0; --i) {
        for (int j = 0; j < i; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```
其中外层循环的 i 表示每次选定的范围的右端点的下标，j 表示当前需要比较选定范围中的第 j + 1 个数和第 j + 2 个数

该代码是未经优化的冒泡排序，其时间复杂度为$O(n^2)$，优化方法是在交换语句的后面使用 bool 值标记，如果未进行交换，则代表序列已经有序，在最好情况下，输入序列本身就有序，则该算法只需进行一次$O(n)$的比较即可确定序列是有序序列

优化后的代码如下

```cpp
void BubbleSort(vector<int>& arr) {
    bool sorted = true;
    for (int i = arr.size() - 1; i >= 0; --i) {
        for (int j = 0; j < i; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                sorted = false;
            }
        }
    }
    if (sorted) {
        return;
    }
}
```
冒泡排序是稳定的排序方法，其最好情况下时间复杂度为$O(n)$（优化后，数组一开始就有序的状态），最坏及平均时间复杂度为$O(n^2)$
# 选择排序
现假设要求序列按升序排列，则选择排序的基本思想如下：

选定数组最左侧的一个数，假设它为数组中最小的元素，然后将它右侧的每个元素与该元素依次比较，寻找是否有比它更小的数，若有，则交换两数，使得更小的元素处于最左侧，将右侧数全部扫描一遍后，最左侧的部分就是有序序列，下一次选定该有序序列右侧的第一个元素，重复这一过程

代码实现如下：
```cpp
void SelectSort(vector<int>& arr) {
    for (int i = 0; i < arr.size(); ++i) {
        for (int j = i + 1; j < arr.size(); ++j) {
            if (arr[i] > arr[j]) {
                swap(arr[i], arr[j]);
            }
        }
    }
}
```
其中外层循环的 i 表示当前选定的最小数的下标，j 表示当前正在比较的右侧数的

选择排序是不稳定的排序方法，其时间复杂度总为$O(n^2)$
# 插入排序
现假设要求序列按升序排列，则插入排序的基本思想如下：

选定一个有序范围（一开始就是最左侧的数），然后在不有序的范围中依次选择元素，与有序的范围中的元素进行类似冒泡排序的比较、交换，直到遇到一个比它小的元素停止

插入排序是稳定的排序算法，其最好情况下（每次插入都在最后，只需要$n - 1$次比较）时间复杂度是$O(n)$，平均和最坏时间复杂度为$O(n^2)$
# 归并排序
现假设要求序列按升序排列，则归并排序的基本思想如下：

要求整个数组有序，可以先将数组分为左右两半，使得左右两半先分别有序，再将左右两半合并为一个有序的数组，要使其左右两半分别有序，则需要将其左右两半再进行分割，直到将每个元素分割成最小的块（每个块包含单个元素），这是一个递归的过程

代码实现如下：
```cpp
void MergeSort(vector<int>& arr, int l, int r) {
    if (l == r) {
        return;
    }
    int mid = (l + r) / 2;
    MergeSort(arr, l, mid);
    MergeSort(arr, mid + 1, r);
    // 合并
    vector<int> temp;
    int i = l, j = mid + 1;
    while (i <= mid && j <= r) {
        if (arr[i] < arr[j]) {
            temp.push_back(arr[i++]);
        } else {
            temp.push_back(arr[j++]);
        }
    }
    while (i <= mid) {
        temp.push_back(arr[i++]);
    }
    while (j <= r) {
        temp.push_back(arr[j++]);
    }
    for (int i = 0; i < temp.size(); ++i) {
        arr[l + i] = temp[i];
    }
}
```
归并排序是稳定的排序方法，其时间复杂度总为$O(nlogn)$
# 快速排序
现假设要求序列按升序排列，则归并排序的基本思想如下：

选定数组中的一个元素作为分组的标志，现在选择最右侧的元素，记为P，将数组划分为 < P, = P, > P的三组