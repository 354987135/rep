# 二分法
## 模板 1
以查询整个数组中是否存在`x`为例，`l`初始为第一个元素的下标，`r`初始为最后一个元素的下标

终止条件为`l = r + 1`，即区间`[l, r]`中无剩余元素
```cpp
std::vector<int> a {1, 3, 5, 6, 7, 9};
int BinarySearch(int x) {
    int l = 0, r = a.size() - 1;
    while (l <= r) {
        int mid = (r - l) / 2 + l; 
        if (a[mid] == x) { // 查找到
            return mid;
        } else if (a[mid] > x) { // x 在 mid 左边
            r = mid - 1;
        } else { // x 在 mid 右边
            l = mid + 1;
        }
    }
    return -1; // 未查找到
}
```
## 模板 2
以查询整个数组中是否存在`x`为例，`l`初始为第一个元素的下标，`r`初始为最后一个元素后一个位置的下标

终止条件为`l = r`，区间`[l, r]`中剩余一个元素
``` cpp
std::vector<int> a {1, 3, 5, 6, 7, 9};
int BinarySearch(int x) {
    int l = 0, r = a.size();
    while (l < r) {
        int mid = (r - l) / 2 + l;
        if (a[mid] > x) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    if (a[l] == x) {
        return l;
    }
    return -1;
}
```
## 模板 3
以查询整个数组中是否存在`x`为例，`l`初始为第一个元素的下标，`r`初始为最后一个元素后一个位置的下标

终止条件为`l + 1 = r`，区间`[l, r]`中有两个元素，其中`r`是`>=x`的数的下标，`l`是`<x`的数的下标
```cpp
int BinarySearch(int x) {
    int l = 0, r = a.size();
    while (l + 1 != r) {
        int mid = (r - l) / 2 + l;
        if (a[mid] < x) {
            l = mid;
        } else {
            r = mid;
        }
    }
    if ()
}
```
## 在有序序列中查找 x 的边界，左边界：>=x 的第一个元素，右边界：>x 的第一个元素
## 在序列中查找极值点，不要求序列有序


## 二分法的时间复杂度
使用二分法对一个序列进行查找的过程中，每次查找后范围都会缩小至原来的一半，记序列总长度为`n`，查找次数为`k`，在足够多次查找后，总能将答案限定在一个长度为`1`的范围中，即 $ n \, / \, 2^k = 1 \Rightarrow 2^k = n \Rightarrow k = log_2n $，对于一个长度为`n`的序列，进行 $ log_2n $ 次查找即可判定目标所在的位置，因此二分法的时间复杂度是 $O(logn)$
## STL中的二分查找函数
下列函数均定义在`<algorithm>`头文件中

- `std::lower_bound(begin, end, x)`

    在以begin和end迭代器标识的有序(按 < 关系有序)range中，寻找第一个不先序于x(即 >= x)的元素，返回该元素的迭代器

- `std::upper_bound(begin, end, x)`: 

    在以begin和end迭代器标识的有序(按 < 关系有序)range中，寻找第一个先序于x(即 > x)的元素，返回指向该元素的迭代器

以上 2 个函数，如果未找到目标元素，则返回传入的 end 迭代器

`std::equal_range(begin, end, x)`: 

同时进行`std::lower_bound(begin, end, x)` 和 `std::upper_bound(begin, end, x)`，以pair形式返回结果，其中first成员是`std::lower_bound(begin, end, x)`的返回值，second成员是`std::upper_bound(begin, end, x)`的返回值
`second - first` 可以得到等于 x 的元素的个数

`std::binary_search(begin, end, x)`: 

在以begin和end迭代器标识的有序(按 < 关系有序)range中，查找是否存在x，返回bool值